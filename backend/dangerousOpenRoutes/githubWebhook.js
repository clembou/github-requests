 const config = require('../../config');
const bodyParser = require('body-parser');
const sgMail = require('@sendgrid/mail');
const requestUtils = require('../../client/src/shared/requestUtils');
const notifications = require('./notifications');
const crypto = require('crypto');
const compare = require('secure-compare');
const { getProxyRequestOptions, genericErrorHandler } = require( '../gitHubProxyHelpers');
const validateRepository = require( '../configHelpers');


const { dangerousOpenRouter } = require('./dangerousOpenRouter');

// handle github web hooks
dangerousOpenRouter.post('/webhook/github-webhooks', [bodyParser.json({verify:verifyRequest})], function(req, res) {
    // this message is unsecured because github doesn't have a token to call us
    // instead we check that this message was generated by our github instance
    // by checking that the signature of the body was created with the correct secret
    console.log(`RequestApp: received web hook action: ${req.headers['x-github-event']}`);
  
    if (isGitHubWebHookRequestValid(req)) {
      sendEmailsForGitHubWebHook(req, res)
    } else {
      handleInvalidGitHubWebHookRequest(req, res);
    }
  });
  
// Verify function compatible with body-parser to retrieve the request payload.
// Read more: https://github.com/expressjs/body-parser#verify
function verifyRequest(req, res, buf, encoding) {
  var expected = req.headers['x-hub-signature'];
  var calculated = getSignature(buf);
  console.log("X-Hub-Signature:", expected, "Content:", "-" + buf.toString('utf8') + "-");
  if (!compare(expected,calculated)) {
    throw new Error("Invalid signature.");
  } else {
    console.log("Valid signature!");
  }
}

// Calculate the X-Hub-Signature header value.
function getSignature(buf) {
  var hmac = crypto.createHmac("sha1", config.github.webHookSecret);
  hmac.update(buf, "utf-8");
  return "sha1=" + hmac.digest("hex");
}

function isGitHubWebHookRequestValid(req)  {
  return ['issues', 'issue_comment'].includes(req.headers['x-github-event']) && userLoginFromGitHubRequestBody(req.body) === config.github.botLogin;
}

function userLoginFromGitHubRequestBody(body){
  return (body && body.issue.user) ? body.issue.user.login : "";
}

function handleInvalidGitHubWebHookRequest(req, res)  {
  console.log('RequestApp: The following github webhook was not valid:');
  console.log(req.headers['x-github-event']);
  console.log(config.github.botLogin);
  console.log(userLoginFromGitHubRequestBody(req.body));
  
  res.status(422).send({
    message: 'The github webhook request is not valid'
  });
}

function sendEmailsForGitHubWebHook(req, res)  {
  try {
    trySendEmailsForGitHubWebHook(req, res);
  } catch (error) {
    handleErrorForEmailsForGitHubWebHook(req, res, error);
  }
}
  
function trySendEmailsForGitHubWebHook(req, res)  {
  const { email } = requestUtils.getCreator(req.body.issue);
  const project = notifications.findProject(req.body, config.appData.projects);
  const requestUrl = notifications.getRequestUrl(req.body.issue.number, project, getlocalAppRootUrl(req));
  const eventType = req.headers['x-github-event'];
  const { subject, content } = notifications.getNotificationText(eventType, req.body, project.name, requestUrl);

  console.log(`Request app: Email notification starting`);

  if (email && subject && content) {
    sendMail(email, subject, content)
      .then(response => {
        console.log(`Request app: Email notification sent successfully to ${email}`);
      })
      .catch(error => {
        //error is an instance of SendGridError
        //The full response is attached to error.response
        console.log(error.response);
      });
  }

  console.log(`Request app: Email notification returning response`);
  res.json({ message: 'web hook processed' });
}
  
function handleErrorForEmailsForGitHubWebHook(req, res, error)  {
  console.log('RequestApp: An error occcured while attempting to process the following github webhook:');
  console.log(error);

  res.status(500).json({
    message: 'An error occcured while attempting to process a github webhook',
  });
}

const sendMail = (to, title, body) => {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
  const msg = {
    to: to,
    from: config.app.emailSender,
    subject: title,
    html: body,
  };
  return sgMail.send(msg);
};

const getlocalAppRootUrl = request => {
  return process.env.NODE_ENV == 'production'
    ? url.format({
        protocol: 'https', // request.protocol returns http for now since the node server itself is only using http. However the api is used over https thanks to azure / IIS
        host: request.hostname,
        // port: request.port,
        pathname: ''
      })
    : 'https://localhost:3000'; // hard coded value in development because the request came through the webpack dev server on a different port and via https.
};
